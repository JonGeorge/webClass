How to Run a Method in the Background using Executor Class
----------------------------------------------------------


ArrayBlockingQueue is backed by an array that size will never change after creation. Setting the capacity to Integer.MAX_VALUE would create a big array with high costs in space. ArrayBlockingQueue is always bounded.

LinkedBlockingQueue creates nodes dynamically until the capacity is reached. This is by default Integer.MAX_VALUE. Using such a big capacity has no extra costs in space. LinkedBlockingQueue is optionally bounded.


Test Class
----------
private ThreadPoolExecutor executorService;



private ThreadPoolExecutor getExecutorService()
{
  if (this.executorService == null)
   {
      ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<Runnable>(100);
      this.executorService = new ThreadPoolExecutor(minpoolsizeValue, maxpoolsze, keepAliveTime, keepAliveUnits, queue);
  }
  
  return this.executorService;
}

public void doSomething()
{
   if (runInBackground == true)
    {
       ThreadPoolExecutor executor = getExecutorService();
      
       if (executor.getQueue().remainingCapacity() > 0)
        {
           // There is room in the queue for this request
          executor.execute(new RunnableWorker(message));
          }
      else
        {
            // The queue is full
            logger.warn("I cannot run this request right now -- the queue is full");
        }
    }      
  else
   { 
       // Run in foreground
       new RunnableWorker(message);
    }
}


public class RunnableWorker implements Runnable
{
  String message;
  
   public RunnableWorker(String aMessage)
    {
       this.message = aMessage;
    }
    
   public void run()
    {
      try
        {
        // Do something
        }
        catch (Exception e)
        {
        logger.error(e);
        }
    }
}
