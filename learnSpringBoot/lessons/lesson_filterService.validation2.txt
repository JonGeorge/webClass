Lesson:  Build a FilterService:  Validation Rules
-------------------------------------------------
The FilterService class has a method called areFiltersValid().

Valid Filters
-------------
     *    Fieldname <separator> EQUALS          value
     *    Fieldname <separator> GREATER         value
     *    Fieldname <separator> GREATER_EQUAL   value
     *    Fieldname <separator> LESS            value
     *    Fieldname <separator> LESS_EQUAL      value
     *    Fieldname <separator> BETWEEN         value1 <separator> value2                        (applies to dates and numeric fields only)
     *    Fieldname <separator> IN              value1 <separator> value2 <separator> value3....
     *    Fieldname <separator> NOTIN           value1 <separator> value2 <separator> value3....
     *    Fieldname <separator> CONTAINS        value1
     *    Fieldname <separator> ICONTAINS       value1
     *    Fieldname <separator> ISNULL
     *    Fieldname <separator> ISNOTNULL



Business Logic
--------------
 a) Determine which operation is being used
 b) Compare the number of tokens vs expected number of tokens



Implementation #1
-----------------
  private boolean isFilterFormatValid(String aFilter) {
        String[] filterTokens = StringUtils.split(aFilter, "~");

        String operation = filterTokens[1];

        if ((operation.equalsIgnoreCase("EQUALS")) && (filterTokens.length != 3)) {
            // Use selected EQUALS but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("GREATER")) && (filterTokens.length != 3)) {
            // Use selected GREATER but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("GREATER_EQUAL")) && (filterTokens.length != 3)) {
            // Use selected GREATER_EQUAL but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("LESS")) && (filterTokens.length != 3)) {
            // Use selected LESS but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("LESS_EQUAL")) && (filterTokens.length != 3)) {
            // Use selected LESS_EQUAL but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("BETWEEN")) && (filterTokens.length != 4)) {
            // Use selected BETWEEN but there is not 4 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("CONTAINS")) && (filterTokens.length != 3)) {
            // Use selected CONTAINS but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("IN")) && (filterTokens.length >= 3)) {
            // Use selected IN but there is not 3 or more fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("NOTIN")) && (filterTokens.length >= 3)) {
            // Use selected IN but there is not 3 or more fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("ISNULL")) && (filterTokens.length != 2)) {
            // Use selected ICONTAINS but there is not 3 fields
            return false;
        }
        else if ((operation.equalsIgnoreCase("ISNOTNULL")) && (filterTokens.length != 2)) {
            // Use selected ICONTAINS but there is not 3 fields
            return false;
        }

        return true;
    }





Implementation #2  (better if statement)
----------------------------------------
The code is longer but there is only 2 if statements that are followed

   private boolean isFilterFormatValid(String aFilter) {
        String[] filterTokens = StringUtils.split(aFilter, "~");

        String operation = filterTokens[1];

        if (operation.equalsIgnoreCase("EQUALS"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("GREATER"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("GREATER_EQUAL"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("LESS"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("LESS_EQUAL"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("BETWEEN"))  {
            if (filterTokens.length == 4) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("CONTAINS"))  {
            if (filterTokens.length == 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("IN"))  {
            if (filterTokens.length >= 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("NOTIN")) {
            if (filterTokens.length >= 3) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("ISNULL")) {
            if (filterTokens.length == 2) {
                return true;
            } else {
                return false;
            }
        }
        else if (operation.equalsIgnoreCase("ISNOTNULL")) {
            if (filterTokens.length == 2) {
                return true;
            } else {
                return false;
            }
        }
        else {
            throw new RuntimeException("Unknown Operation name found: Operation=" + operation);
        }
    }


Implementation #3
-----------------
In this approach, the code is simplified


    private boolean isFilterFormatValid(String aFilter) {
        String[] filterTokens = StringUtils.split(aFilter, "~");

        String operation = filterTokens[1];

        if (operation.equalsIgnoreCase("EQUALS"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("GREATER"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("GREATER_EQUAL"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("LESS"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("LESS_EQUAL"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("BETWEEN"))  {
            return filterTokens.length == 4;
        }
        else if (operation.equalsIgnoreCase("CONTAINS"))  {
            return filterTokens.length == 3;
        }
        else if (operation.equalsIgnoreCase("IN"))  {
            return filterTokens.length >= 3;
        }
        else if (operation.equalsIgnoreCase("NOTIN")) {
            return filterTokens.length >= 3;
        }
        else if (operation.equalsIgnoreCase("ISNULL")) {
            return filterTokens.length == 2;
        }
        else if (operation.equalsIgnoreCase("ISNOTNULL")) {
            return filterTokens.length == 2;
        }
        else {
            throw new RuntimeException("Unknown Operation name found: Operation=" + operation);
        }
    }




Implementation #4
-----------------
Create a map that holds key=operation name   and value=ConditionLogic
Then, use that map to check if the operation name exists and if the number of tokens is valid

    private HashMap<String, Integer> mapOperationComparisonOperation = new HashMap<>();

    @PostConstruct
    public void init() {
        mapOperationComparisonOperation.add("EQUALS",        new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("GREATER",       new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("GREATER_EQUAL", new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("LESS",          new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("LESS_EQUAL",    new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("BETWEEN",       new ComparisonOperation("==", 4));
        mapOperationComparisonOperation.add("CONTAINS",      new ComparisonOperation("==", 3));
        mapOperationComparisonOperation.add("IN",            new ComparisonOperation(">=", 3));
        mapOperationComparisonOperation.add("NOTIN",         new ComparisonOperation(">=", 3));
        mapOperationComparisonOperation.add("ISNULL",        new ComparisonOperation("==", 2));
        mapOperationComparisonOperation.add("ISNOTNULL",     new ComparisonOperation("==", 2));
    }

    private boolean isFilterFormatValid(String aFilter) {
        String[] filterTokens = StringUtils.split(aFilter, "~");

        String operationName = filterTokens[1];

        ComparisonOperation co = mapOperationComparisonOperation.get(operationName);
        if (co == null) {
            throw new RuntimeException("I did not find the operation name.");
        }

        int expectedFilterTokensLength = co.getFilterTokensLength();
        if (co.getComparisonOperator.equalsIgnoreCase("==")) {
            return filterTokens.length == expectedFilterTokensLength;
        }
        else if (co.getComparisonOperator.equalsIgnoreCase(">=")) {
            return filterTokens.length >= expectedFilterTokensLength;
        }
        else if (co.getComparisonOperator.equalsIgnoreCase("<=")) {
            return filterTokens.length <= expectedFilterTokensLength;
        }
    }



Implementation #5
-----------------
Create an enumerated type that holds the operations

    EQUALS("EQUALS", 3),
    GREATER("GREATER", 3),
    ...
