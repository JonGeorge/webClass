Fundamentals of Unit Tests w/JUnit and Spring
---------------------------------------------

Lessons
-------
 1. Unit tests java code is found in /src/test/java
 2. Production java code is found in /src/main/java
 3. Unit test code can access everything in /src/main/java


References
----------
https://blog.codecentric.de/en/2017/02/integration-testing-strategies-spring-boot-microservices/


Good Practices
--------------
 1. Writing unit tests is expensive
    -- If you're going to spend the time on a unit test, make it a good one

 2. Create a separate logback-test.xml for unit tests
    NOTE:  Logback looks for logback-test.xml
           So, I would create one in /src/test/resources/logback-test.xml

             <?xml version="1.0" encoding="windows-1252" ?>
             <configuration debug="false">
                 <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                     <encoder>
                         <pattern>%d{MM/dd/yyyy HH:mm:ss} %-5level %c %m%n</pattern>
                     </encoder>
                 </appender>

                 <logger name="org.springframework" level="WARM" additivity="false">
                     <appender-ref ref="CONSOLE"/>
                 </logger>

                 <logger name="com.lessons" level="DEBUG" additivity="false">
                     <appender-ref ref="CONSOLE"/>
                 </logger>

                 <root level="WARN">
                     <appender-ref ref="CONSOLE"/>
                 </root>
             </configuration>



Create a FilterTestClass that tests your FilterService
------------------------------------------------------
 1. Add the spring-boot-starter-test dependency
         <dependency>
              <groupId>org.springframework.boot</groupId>
              <artifactId>spring-boot-starter-test</artifactId>
              <version>2.0.0.RELEASE</version>
              <scope>test</scope>
          </dependency>

    NOTES:
       a. The <scope> tag holds test because we do not want to include this with production code
       b. The spring-boot-starter-test contains Junit 4, Spring Test, AssertJ, Hamcredt, Mockito, JSONassert, and JsonPath
       b. The spring-boot-starter-test version should match your spring-boot version

        So, your spring boot version should look like this:

                <!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot -->
                <dependency>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot</artifactId>
                    <version>2.0.0.RELEASE</version>
                </dependency>


 2. Create a class that ends with "Test" in the /src/test/java
    a. Right-click on /src/test/java/com/lessons-> New Java Class
    b. ClassName:  FilterServiceTest
    c. Replace your class with this:


          package com.lessons;

          import com.lessons.filter.FilterService;
          import org.junit.Test;
          import org.junit.runner.RunWith;
          import org.slf4j.Logger;
          import org.slf4j.LoggerFactory;
          import org.springframework.boot.test.context.SpringBootTest;
          import org.springframework.test.context.junit4.SpringRunner;

          import javax.annotation.Resource;
          import java.util.Arrays;
          import java.util.List;

          import static org.hamcrest.Matchers.is;
          import static org.junit.Assert.assertThat;
          import static org.junit.Assert.assertTrue;

          @RunWith(SpringRunner.class)    // Required to work with JUnit 4
          @SpringBootTest                 // Start up a Spring Application Context
          public class FilterServiceTest {

              private static final Logger logger = LoggerFactory.getLogger(FilterServiceTest.class);

              @Resource
              private FilterService filterService;

              @Test
              public void testValidFormat1() {
                  logger.debug("testValidFormat1() started.");

                  // Create an array of filters
                  List<String> filters = Arrays.asList("ID~EQUALS~5");

                  // Run the test
                  boolean bFiltersAreValid = filterService.areFiltersValid(filters);

                  // Old way of verifying result
                  assertTrue("Filter did not have the expected match", bFiltersAreValid==Boolean.TRUE);

                  // Newer way of verifying result
                  assertThat("Filter did not have the expected match", bFiltersAreValid, is(Boolean.TRUE));

                  logger.debug("testValidFormat1() finished.");
              }

          }



 3. Run this single test case with the Intellij debugger
    a. Set a breakpoint on this line:
            boolean bFiltersAreValid = filterService.areFiltersValid(filters);
    b. Right-click on testValidFormat1 -> Debug


 4. Run this single test case from command-line
    a. Open a unix terminal
       unix> cd ~/intellijProjects/app1/webapp
       unix> mvn clean test -Dtest=FilterServiceTest

    b. You should see this:

        [INFO]
        [INFO] -------------------------------------------------------
        [INFO]  T E S T S
        [INFO] -------------------------------------------------------
        [INFO] Running com.lessons.FilterServiceTest

          .   ____          _            __ _ _
         /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
        ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
         \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
          '  |____| .__|_| |_|_| |_\__, | / / / /
         =========|_|==============|___/=/_/_/_/
         :: Spring Boot ::            (v2.0.0.RC1)

        06/02/2019 21:25:10 INFO  com.lessons.FilterServiceTest Starting FilterServiceTest on myCentos7 with PID 28699 (started by adam in /home/adam/intellijProjects/app1/webapp)
        06/02/2019 21:25:10 DEBUG com.lessons.FilterServiceTest Running with Spring Boot v2.0.0.RC1, Spring v5.0.3.RELEASE
        06/02/2019 21:25:10 INFO  com.lessons.FilterServiceTest No active profile set, falling back to default profiles: default
        06/02/2019 21:25:10 DEBUG com.lessons.services.DashboardDao DashboardDao() Constructor called
        06/02/2019 21:25:11 DEBUG com.lessons.services.DashboardDao stuff=null
        06/02/2019 21:25:11 DEBUG com.lessons.filter.FilterService init() started.
        06/02/2019 21:25:11 DEBUG com.lessons.filter.FilterService b=true
        06/02/2019 21:25:11 DEBUG com.lessons.services.FilterSortService init() started.
        06/02/2019 21:25:12 INFO  com.lessons.FilterServiceTest Started FilterServiceTest in 2.316 seconds (JVM running for 2.878)
        06/02/2019 21:25:12 DEBUG com.lessons.FilterServiceTest testValidFormat1() started.
        06/02/2019 21:25:12 DEBUG com.lessons.filter.FilterService areFiltersValid() started.
        06/02/2019 21:25:12 DEBUG com.lessons.FilterServiceTest testValidFormat1() finished.
        [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.855 s - in com.lessons.FilterServiceTest
        [INFO]
        [INFO] Results:
        [INFO]
        [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
        [INFO]
        [INFO] ------------------------------------------------------------------------
        [INFO] BUILD SUCCESS
        [INFO] ------------------------------------------------------------------------
        [INFO] Total time: 9.163 s
        [INFO] Finished at: 2019-06-02T21:25:12-04:00
        [INFO] Final Memory: 26M/400M
        [INFO] ------------------------------------------------------------------------


 5. Change the unit test class so it starts-up a full-fledged app server
    a. Add this to your logback-test.xml
         <?xml version="1.0" encoding="windows-1252" ?>
         <configuration debug="false">
             <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                 <encoder>
                     <pattern>%d{MM/dd/yyyy HH:mm:ss} %-5level %c %m%n</pattern>
                 </encoder>
             </appender>

             <logger name="org.springframework" level="DEBUG" additivity="false">
                 <appender-ref ref="CONSOLE"/>
             </logger>

             <logger name="com.lessons" level="DEBUG" additivity="false">
                 <appender-ref ref="CONSOLE"/>
             </logger>

             <root level="DEBUG">
                 <appender-ref ref="CONSOLE"/>
             </root>
         </configuration>


    b. Change the @SpringBootTest annotation to this:
         @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)

    c. Kick off the unit test from command-line:
       You should see this:
          06/02/2019 21:39:19 INFO  org.springframework.boot.web.embedded.undertow.UndertowServletWebServer Undertow started on port(s) 33516 (http) with context path '/app1'


       Why do this?
       -- The unit test class is creating a real app server
       -- So, we can send real POST calls to http://localhost:${local.server.port} and it will be routed to this app server
       -- The RestTemplate object lets us make REST calls
          example:


                @Value("${local.server.port}")
                private String appServerPort;       // Holds the port that the test app server is listening on

                @Test
                public void testDashboardControllerGetTime2() {
                    RestTemplate restTemplate = new RestTemplate();

                    // Construct the URL to connect to this REST endpoint
                    String url = "http://localhost:" + appServerPort + "/app1/api/dashboard/time";

                    // Invoke the REST endpoint and get the response
                    String dateTime = restTemplate.getForObject(url, String.class);

                    assertTrue("Expected dateTime to be non-null", (dateTime != null));
                }

