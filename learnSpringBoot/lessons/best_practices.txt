Best Practices
--------------
Here are my recommended best practices in no particular order



General Best Practices
----------------------
 1. Use a Java debugger -- e.g., IntelliJ, Eclipse
    + It is your most valuable resources as a Java programmre

 2. Use a Logger instead of print statements -- e.g., LogBack or log4j
    Every professional project I had used loggers (not print statements).
    + It's easy to turn-on/turn-off logging across a large project
    + You can change the logger settings without having to recompile code
    - When you copy+paste logger code to a new class, make sure you update the class name

 3. Know the difference between primitives and Java Objects
    + Java objects can be null (primitives cannot)

 4. If your class *requires* something to operate correctly, then use a constructor to enforce it

 5. Maven makes it really easy to bring-in code into your project
    - Don't forget to remove unused dependencies
    - Use dependency:tree to see all of the dependencies

 6. Know how Java handles call-by-value and call-by-reference
    Better yet:  Don't change objects that are passed-in and simply return new ones

 7. If your method needs to return 3 things, then create an object and return that object

 8. Use a check-in/checkout-out repository like Git

 9. Know the differences between lists and Fixed Arrays
    -- The List<String> return from StringUtils stlil has a fixed array under the hood and is immutable

10. Use static methods for your own String Utilities class

11. Use System class to end your application with an exit code
    Use System class to time a method

12. StringUtils is your friend  (from org.apache.commons.lang3.StringUtils)
    -- Be warned:  You sometimes get a fixed array back (not a Java List)
    -- Know how to use Arrays.asList as a bridge between the fixed array world and java list world

13. When working with an ArrayList or HashMap, have your method return the Map or List class
    List<String> list = new ArrayList<>();
    ...
    return list;

14. Use try-with-resources instead of try-catch-finally
    -- Any class that implements AutoClosable automatically is closed
    -- close() method is called first  (before exception handlers)



Database Best Practices
-----------------------
  1. Use a connection pool   [best optimization you'll make]
     -- Hikari is the fastest, but anything is better than nothing

  2. Have your service classes run raw SQL
     + Faster than hibernate
     - Requires knowledge of SQL
     - Requires you to actually design tables [which is a good thing]



Spring Best Practices
---------------------
 1. Use constructor injection for mandatory dependencies

 2. Know the 3 ways to run a Spring-Boot App
    a. Using Intellij by debugging main Application class
    b. Run app from command-line using spring-boot maven plugin
    c. Run app from command-line using uber jar

 3. Know how to inject values into your spring beans

 4. Know how to override values on the command-line using -D

 5. Using id= is fine on the URL
    Using id for a variable sucks
    -- If the id is a reportId, then make sure your variable is called reportId (and not id)

        @RequestMapping(value = "/api/getStuff", method = RequestMethod.GET, produces = "application/json")
        public ResponseEntity<?> getStuff(@RequestParam(name="id") Integer reportId) {

        }

 6. Understand the difference between sending a single JSON body to your REST endpoint vs multiple parameters

 7. RowMapper is handy but be careful:  If you select columns are fewer than your DTO object, you will get null values in your DTO
    -- RowMapper fails silently so check your code with a debugger

 8. If your front-end needs to rename a field, then use @JsonProperty in your DTO


Contract Best Practices
-----------------------
 1. Always ask "What is getting returned?" after the REST call is finished?
    -- It may return only a 200 status code (and that's fine)
       For REST calls that perform writes, the front-end often makes another REST call to refresh the page after invoking a REST call
       so often nothing needs to be returned.
    -- It may return an entire object and status code



Strange Errors
--------------
 1. Problem:  I added a new controller and a new REST endpoint method.  But, I keep getting 404 error.
    Solution: My controller was missing the @Controller annotation
              -- Without the @Controller annotation, your controller class is not instantiated.



